module SAXS_scoring

  use geometric_corrections
  implicit none
  ! A (somewhat) protected UNIT for file I/O
  integer :: QFILE = 123

  ! SAXS Curve Parameters
  real*8 :: max_q = 1.0d0
  integer :: num_points = 200   ! CHANGED from 201
  real*8 :: delta_q
  real*8 :: delta_w

  ! Explicit Hydration Parameters
  real*8 :: dx
  integer :: n_shells

  ! Use and Definition of Target Curve
  logical :: use_target = .true.
  real*8, dimension(:), allocatable :: target_curve
  real*8 :: target_curve_relative_threshold  = 0.05 ! Threshold used in check_SAXS_consistency() to detect inconsistency between target_curves and structures

  ! Use and Definition of mean correction Curve
  logical :: use_mean_correction = .true.
  real*8, dimension(:), allocatable :: mean_correction_curve
  character*100 :: mean_correction_file

  ! Genetic Algorithms Parameters ! UNUSED
  real*8 :: survival_rate ! Proportion of the population that will be discarded
  integer :: population_count = 0

  ! Computation Schemes
  logical :: in_solution_curve = .false. ! .true for In Solution curve, .false. for In Vacuo
  logical :: explicit_sol_contribution = .false. ! .true. for explicit removal of solvent contribution, .false. for implicit via corected FF
  logical :: refine_hydration_layer = .false. ! .true. for adding an extra hydration layer with enhanced electron density, .false. otherwise
  logical :: linear_intensity = .false.

  ! SAXS energy parameters
  integer :: SAXS_norm_type = 2 ! 1 for 1-norm, 2 for 2-norm, 3 for infinity-norm
  real*8 :: SAXS_vect_max = 1.0d0 
  !real*8, dimension(1:2) :: SAXS_norm_range = (/ 0.0d0, 0.995d0 /) ! UNUSED

  ! FA / CG parameters
  logical :: coarse_grained = .true. ! .true. for CG, .false. for FA (Full-Atom) otherwise
  character*30 :: parameter_file = 'SAXS_grains.dat' ! Either SAXS_grains.dat or SAXS_atoms.dat

  ! Solvent Parameters
  character*4 :: solvent_name = 'HOH '
  real*8 :: solvent_contrast = 0.0
  real*8 :: solvent_electron_density = 0.334
  real*8 :: SAXS_w_shell = 0.3d0

  ! Module Private Variables
  real*8 :: max_distance = 100.0d0
  real*8, dimension(:), allocatable :: sinc_A ! Tabulated cardinal sine function
  integer, parameter :: w_max = 50000
  integer :: MAXSOL = 5000 ! Slightly dynamic, will be increased if necessary
  integer :: num_atoms ! A raw copy of NATOMS (defined in module defs)

  ! Grain specific data
  character*5, dimension(:), allocatable :: Grains
  integer :: grain_number = 0
  real*8, dimension(:,:), allocatable :: F_grains
  real*8, dimension(:), allocatable :: Grains_cutoff, Grains_excludedVol, Grains_excludedRadii, Grains_electron_density

  ! Other
  character*1, parameter :: comment_pattern='#'
  logical :: regen_corrected_FF = .false.
  character*180 :: saxs_input_file = "SAXS"
  real*8 :: saxs_alpha = 200.0 ! Coefficient used in Energy Term, in KJ.(...)
  !integer, dimension(1:2) :: SAXS_norm_range_point ! UNUSED
  integer :: max_q_point

  contains

    !> @brief Setter method for the parameters of the entire module.
    !> Used for setting up simulation parameters, as well as whecking the existence/generating form factors.
    subroutine set_SAXS_scoring()
      use defs
      implicit none
      integer :: point_q
      logical :: found_mean_correction = .false.
      real*8 :: q

      num_atoms = NATOMS
      delta_q = max_q / num_points
      population_count = N_REPLICA
      !SAXS_norm_range_point(:) = int(SAXS_norm_range(:) / delta_q)
      max_q_point = int(SAXS_Vect_Max / delta_q)

      if (use_target) then
        ! Allocate target SAXS with target file ...
        allocate(target_curve(0:num_points - 1))
        ! ... and fill it
        open(unit=QFILE, file='saxs_target.dat', status='old')
        q_loop: do point_q = 0, num_points - 1
          read(QFILE,*), q, target_curve(point_q)
        end do q_loop
        close(QFILE)
      end if

      select_correction_file: if (in_solution_curve) then
        mean_correction_file = "saxs_mean_correction_Solution.dat"
      else
        mean_correction_file = "saxs_mean_correction_Vacuo.dat"
      end if select_correction_file
      ! Then, ensure its existence
      inquire(file=mean_correction_file, exist=found_mean_correction)
      ! Abort if asked for the correction but can't find the correcting file
      if (use_mean_correction .and. .not. found_mean_correction) then
        print *, 'Could not find mean correction file ', trim(mean_correction_file)
        STOP 5
      end if

      use_mean_correction = use_mean_correction .and. found_mean_correction .and. coarse_grained ! Correction only applies to CG curves
      if (use_mean_correction ) then
        ! Allocate mean correction SAXS with mean correction file ...
        allocate(mean_correction_curve(0 : num_points - 1))
        ! ... and fill it
        open(unit=QFILE, file=mean_correction_file, status='old')
        do point_q = 0, num_points - 1
          read(QFILE,*), q, mean_correction_curve(point_q)
        end do
        close(QFILE)
      end if

      ! Depending on calculation type (FA, CG), change the input parameter file
      if (coarse_grained) then
        parameter_file = 'SAXS_grains.dat'
        call init_hash_CG()
      else
        parameter_file = 'SAXS_atoms.dat'
        call init_hash_FA()
      end if

      ! Init hashes and arrays
      call tabulate_sinc()

    end subroutine set_SAXS_scoring


    !> @brief This method, which should only be called once, ensures that the structures on which
    !> we will be calculating SAXS profiles have a number of electrons matching the target ones
    !> (otherwise, there is obviously an error either in the target or in the structure, but trying
    !> to match them makes no sense and should be avoided)
    subroutine check_SAXS_consistency(pos, ATOMIC_TYPE)
      real*8, dimension(1:3*num_atoms), intent(in) :: pos
      character*5, dimension(1:num_atoms), intent(in) :: ATOMIC_TYPE

      real*8, dimension(0 : max_q_point - 1) :: curve1
      double precision :: Esaxs, F_saxs(3*num_atoms)

      call fct_generate_SAXS_curve(pos, ATOMIC_TYPE, curve1, Esaxs, F_saxs)
      !curve1(0:num_points-1) = fct_generate_SAXS_curve(pos, ATOMIC_TYPE) ! ATOMIC_TYPE is sourced in 'module defs'
      if ( abs(10**curve1(0) - 10**target_curve(0) ) >= target_curve_relative_threshold * 10**target_curve(0) ) then
        print '(A ES15.7 A ES15.7 A)', 'check_SAXS_consistency(): The target SAXS profile (',10**target_curve(0),') does not match &
           &the calculated SAXS profile (',10**curve1(0),') in q=0 &
           &which is symptomatic of something being very wrong. SAXS_scoring will abort the calculations for your own sake.'
        STOP 5
      end if
    end subroutine check_SAXS_consistency

    !> @brief Tabulates sin_c using w_max (max array size) and max_distance.
    !> Needs to be called everytime max_distance is updated.
    subroutine tabulate_sinc()
      implicit none
      integer :: point_w

      delta_w = (max_distance * max_q) / (0.99 * w_max)

      ! This method can be called multiple times if we increase max_distance, distance so we have to be careful not to allocate twice
      if (.not. allocated(sinc_A)) allocate(sinc_A(0:w_max))
      sinc_A(0)=1.0d0
      tabulate: do point_w=1,w_max
        sinc_A(point_w) = sin(point_w*delta_w) / (point_w*delta_w)
      end do tabulate
    end subroutine tabulate_sinc


    !> @brief Called by saxs_header to output SAXS options to FSAXS (saxs_convergence.dat)
    subroutine write_SAXS_options_to_unit(FUNIT)
    implicit none
    integer, intent(in) :: FUNIT

    write(FUNIT,'(A35 I12   )') 'Number of SAXS Grains found  :     ', grain_number
    write(FUNIT,'(A35 A12   )') 'Curve Type                   :     ', merge(' In Solution', '    In Vacuo', in_solution_curve)
    if ( in_solution_curve .and. refine_hydration_layer ) then
      write(FUNIT,'(A35 f12.10)') 'Dummy Water Radius           :     ', dx
      write(FUNIT,'(A35 I12   )') 'Dummy Water Shells           :     ', n_shells
    end if

    end subroutine write_SAXS_options_to_unit

    !> @brief Call this method to update the SAXS score of a conformation.
    subroutine compute_score(conformation, write_to_unit)
      use defs
      implicit none
      type(t_conformations), intent(inout) :: conformation
      integer, optional :: write_to_unit
      real*8, dimension(0 : max_q_point - 1) :: curve1
      double precision :: Esaxs
      double precision, dimension(1:3*num_atoms) :: F_saxs

      ! Generate SAXS Curve
      call fct_generate_SAXS_curve(conformation%pos, ATOMIC_TYPE, curve1, Esaxs, F_saxs)
      !curve1(0:num_points-1) = fct_generate_SAXS_curve(conformation%pos, ATOMIC_TYPE) ! ATOMIC_TYPE is sourced in 'module defs'
      
      ! Compute the new score, and set it
      conformation%score = norm_curves(curve1, target_curve)

      if ( present(write_to_unit)) call write_SAXS_curve_to_unit(curve1,write_to_unit)

    end subroutine compute_score


    !> @brief Returns the (log10) SAXS intensity of a given structure (pos + atomNames).
    !function fct_generate_SAXS_curve(pos, ATOMIC_TYPE) result(I_tot)
    subroutine fct_generate_SAXS_curve(pos, ATOMIC_TYPE, logI, Esaxs, F_saxs)

      use defs, only: use_qbug
      implicit none
      real*8, dimension(1:3*num_atoms) :: pos
      character*5, dimension(1:num_atoms) :: ATOMIC_TYPE
      character*5, dimension(:), allocatable :: AtomNames_TOT
      real*8, dimension(0:max_q_point-1) :: logI, I1, I0
      real*8 :: max_val
      double precision, dimension(1:3*num_atoms) :: F_saxs
      double precision :: r(3), F_grain(3), r2, qr, qphys, cscale, Esaxs, E_den, E_num, cscale_num, cscale_den, F_pre
      integer :: i, j, ps
      real*8 :: F
      real*8, dimension(:), allocatable :: pos_SOL, pos_TOT ! TOT = SYSTEM + SOL
      real*8, dimension(:,:), allocatable :: DistanceMatrix_TOT, F_CG_TOT
      integer :: grain_i, grain_j, q, num_TOT, num_SOL
#ifdef DEBUG_TIME
      real*8 :: time1, time2
      call cpu_time(time1)
#endif

      PRINT *, "START GENERATING SAXS CURVE" !lm759 test
      if_refine_hydration_layer: if (in_solution_curve .and. refine_hydration_layer) then
        allocate( pos_SOL(1:3*MAXSOL) )
        pos_SOL = 0.0 ! SAXS-On-The-Fly : Is the initialization necessary ?

        ! Hydrate in pos_SOL
        call hydrate_pos_outer_shell(pos, ATOMIC_TYPE, num_SOL, pos_SOL)
        num_TOT = num_atoms + num_SOL

        ! Allocate pos_TOT with the new solvent molecules
        allocate( pos_TOT(1:3*num_TOT) )
        pos_TOT(1:3*num_atoms) = pos(1:3*num_atoms)
        pos_TOT(3*num_atoms+1:3*num_TOT) = pos_SOL(1:3*num_SOL)

        ! Fill AtomNames_TOT
        allocate(AtomNames_TOT(num_TOT))
        AtomNames_TOT(1:num_atoms) = ATOMIC_TYPE(1:num_atoms)
        AtomNames_TOT(num_atoms+1:num_TOT) = 'HOH  '

        ! Allocate F_CG_TOT and fill it
        allocate( F_CG_TOT(0 : num_points - 1, 1 : num_TOT) )
        call fill_structureFactor_array(num_TOT, AtomNames_TOT, F_CG_TOT )! SAXS-On-The-Fly : Need to resize (and fill) ATOMIC_TYPE

        ! Allocate DistanceMatrix_TOT and fill it
        allocate( DistanceMatrix_TOT(1:num_TOT, 1:num_TOT) )
        call fill_half_distance_matrix(num_TOT,pos_TOT,DistanceMatrix_TOT)

      else ! (.not refine_hydration_layer .or. .not. in_solution_curve)
        num_TOT=num_atoms
        ! Allocate F_CG_TOT and fill it
        allocate( F_CG_TOT(0 : num_points - 1, 1 : num_TOT) )
        call fill_structureFactor_array(num_TOT, ATOMIC_TYPE, F_CG_TOT )! SAXS-On-The-Fly : Need to resize (and fill) ATOMIC_TYPE
        ! Allocate DistanceMatrix_TOT and fill it
        allocate( DistanceMatrix_TOT(1:num_TOT, 1:num_TOT) )
        allocate( pos_TOT(1:3*num_atoms) )
        call fill_half_distance_matrix(num_TOT, pos, DistanceMatrix_TOT)
        pos_TOT(1:3*num_atoms) = pos(1:3*num_atoms)

      end if if_refine_hydration_layer

! Initialize vars
      I1 = 0.0d0
      F_saxs = 0.0d0
      cscale = 0.0d0
      cscale_num = 0.0d0
      cscale_den = 0.0d0
      E_den = 0.0d0
      E_num = 0.0d0

! Enforce that DistanceMatrix does not overflow max_distance: WE DON'T USE THE TABULATED SINC
      !max_val = maxval(DistanceMatrix_TOT)
      !if(max_distance <= max_val ) then
      !  print *, 'DistanceMatrix_TOT max value:', max_val
      !  max_distance = 1.5d0 * max_val
      !  call tabulate_sinc()
      !  print *, 'System too large compared to sampling size. Increasing distance_max.'
      !end if

! q_loop_0
      do grain_i = 1, num_TOT
        I1(0) = I1(0) + F_CG_TOT(0,grain_i)**2
        do grain_j = grain_i+1, num_TOT
          I1(0) = I1(0) + 2 * F_CG_TOT(0,grain_i) * F_CG_TOT(0,grain_j)
#ifdef DEBUG_NAN
          if ( isNaN( I1(0) )) then
            print *,'q: ', 0, 'grain_i: ', grain_i, 'grain_j: ', grain_j, 'Distance: ', DistanceMatrix_TOT(grain_j,grain_i)
            STOP 'Detected NaN'
          end if
#endif
        end do
      end do

      PRINT*, "I(0) ", I1(0), log10(I1(0))

      q_loop: do q = 1, max_q_point - 1
        do grain_i = 1, num_TOT
! Add diagonal term (i,i) once
          I1(q)  = I1(q) + F_CG_TOT(q,grain_i)**2
! Add half non-diagonal terms twice
          do grain_j = grain_i+1, num_TOT
             I1(q)  = I1(q) + 2 * F_CG_TOT(q,grain_i) * F_CG_TOT(q,grain_j) * &
                 & sin(DistanceMatrix_TOT(grain_j,grain_i) * q * delta_q) / &
                 & (q * delta_q * DistanceMatrix_TOT(grain_j,grain_i)) 
             !sinc_A( int(DistanceMatrix_TOT(grain_j,grain_i) * q * delta_q / delta_w) )
#ifdef DEBUG_NAN
            if ( isNaN( I1(q) )) then
              print *,'q: ', q, 'grain_i: ', grain_i, 'grain_j: ', grain_j, 'Distance: ', DistanceMatrix_TOT(grain_j,grain_i)
              STOP 'Detected NaN'
            end if
#endif
          end do
        end do
      end do q_loop

      ! Log10 everything
      logI(:) = log10(I1(:))
      ! Define linear TARGET curve
      I0(:) = 10**target_curve(:) 

      ! If there is a correction to use, do it
      if (use_mean_correction) then
        logI(:) = logI(:) + mean_correction_curve(:)
        I1(:) = 10**logI(:)
      end if

      ! Compute E_saxs and F_saxs

      ! USE ONLY IF cscale
      !   do q = 0, max_q_point 
      !     qphys = q * delta_q
      !     cscale_num = cscale_num + qphys**2 * I0(q) * I1(q)
      !     cscale_den = cscale_den + qphys**2 * I1(q)**2
      !   enddo
      !   cscale = cscale_num / cscale_den
      
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Previous attempts !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !   F_new=0.d0                                                                            
      !############################# SCORE weighted R C=1 ######################################
      !   cscale = 1.0
      !   do q = SAXS_norm_range_point(1)-1,SAXS_norm_range_point(2)-1
      !     qphys = q * delta_q
      !     E_den = E_den + qphys**2 * cscale * I1(q) * I0(q)
      !     E_num = E_num + qphys**2 * ( cscale * I1(q) - I0(q) )**2
      !   F_new= F_new+ qphys**2 * I1(q) **2
      !   enddo
      !   Esaxs = ( 1.0 / num_points ) * ( E_num / E_den )          ! OKKIO normalization
      !   do q = SAXS_norm_range_point(1)-1,SAXS_norm_range_point(2)-1
      !      qphys=q * delta_q
      !      F_pre=-qphys**2*cscale/E_den*(2*(cscale*I1(q)-I0(q))-num_points*Esaxs*I0(q))  
      !############################# SCORE weighted R C(q) #####################################
      !   do q = SAXS_norm_range_point(1)-1,SAXS_norm_range_point(2)-1
      !     qphys = q * delta_q
      !     E_den = E_den + qphys**2 * cscale * I1(q) * I0(q)
      !     E_num = E_num + qphys**2 * ( cscale * I1(q) - I0(q) )**2
      !   F_new= F_new+ qphys**2 * I1(q) **2
      !   enddo
      !   Esaxs = ( 1.0 / num_points ) * ( E_num / E_den )
      ! 
      !   do q = SAXS_norm_range_point(1)-1,SAXS_norm_range_point(2)-1
      !      qphys=q * delta_q
      !      F_pre=-qphys**2*cscale/E_den*(2*(cscale*I1(q)-I0(q))&
      !           &+num_points*Esaxs*(cscale-2*I0(q))+2*(cscale-I0(q))&   
      !           &-2*(cscale-I0(q))*F_new/cscale_den)/num_points
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Previous attempts (end) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
            
      !############################# SCORE X2 C=1 ############################################## 
      cscale = 1
      do q = 1, max_q_point - 1
        qphys = q * delta_q
        E_num = E_num + ((cscale * I1(q) - I0(q)) * qphys)**2
        F_pre = - 2 * (cscale * I1(q) - I0(q)) * qphys**2 / (max_q_point * I1(0)**2) ! NORMALIZATION ?
      
      !############################ Derivative with respect to R -> forces ######################     
         do grain_i = 1, num_atoms
            do grain_j = grain_i+1, num_tot
               r = pos_TOT(grain_i*3-2:grain_i*3) - pos_TOT(grain_j*3-2:grain_j*3)
               r2 = dot_product(r,r)
               qr = qphys * dsqrt(r2)
               F_grain = ( r / r2 ) * F_CG_TOT(q, grain_i) * F_CG_TOT(q, grain_j) * ( cos(qr) - sin(qr) / qr )
               F_saxs(grain_i*3-2:grain_i*3) = F_saxs(grain_i*3-2:grain_i*3) + 2 * F_pre * F_grain
               if (grain_j .le. num_atoms) then
                   F_saxs(grain_j*3-2:grain_j*3) = F_saxs(grain_j*3-2:grain_j*3) - 2 * F_pre * F_grain
               endif
            enddo
         enddo
      enddo
      
      Esaxs = E_num / (max_q_point * I1(0)**2)  ! NORMALIZATION ?
        
      ! Deallocate everything
      if (in_solution_curve .and. refine_hydration_layer) then
        deallocate(F_CG_TOT, AtomNames_TOT, pos_SOL, DistanceMatrix_TOT, pos_TOT)
      else
        deallocate(F_CG_TOT, DistanceMatrix_TOT)
      end if

#ifdef DEBUG_TIME
      call cpu_time(time2)
      print *, 'fct_generate_SAXS_curve : ',time2-time1
#endif
      return

    !end function fct_generate_SAXS_curve
    end subroutine fct_generate_SAXS_curve

    !> @brief Returns the (log10) SAXS intensity of a given structure (pos + atomNames).
    function fct_generate_reference_SAXS_curve(pos, ATOMIC_TYPE) result(I_tot)

      implicit none
      real*8, dimension(1:3*num_atoms) :: pos
      character*5, dimension(1:num_atoms) :: ATOMIC_TYPE
      character*5, dimension(:), allocatable :: AtomNames_TOT
      real*8, dimension(0 : num_points - 1) :: I_tot

      real*8, dimension(:), allocatable :: pos_SOL ! TOT = SYSTEM + SOL
      real*8, dimension(:,:), allocatable :: DistanceMatrix_TOT, F_CG_TOT
      integer :: grain_i, grain_j, q, num_SOL

      allocate( pos_SOL(1:3*MAXSOL), AtomNames_TOT(1:MAXSOL) )
      pos_SOL = 0.0 ! SAXS-On-The-Fly : Is the initialization necessary ?
      ! Hydrate in pos_SOL
      call hydrate_pos_fill(pos, ATOMIC_TYPE , num_SOL, pos_SOL, AtomNames_TOT)
      ! Allocate F_CG_TOT and fill it
      allocate( F_CG_TOT(0 : num_points - 1, 1 : num_SOL) )
      call fill_structureFactor_array(num_SOL, AtomNames_TOT, F_CG_TOT )! SAXS-On-The-Fly : Need to resize (and fill) ATOMIC_TYPE
      ! Allocate DistanceMatrix_TOT and fill it
      allocate( DistanceMatrix_TOT(1:num_SOL, 1:num_SOL) )
      call fill_half_distance_matrix(num_SOL,pos_SOL,DistanceMatrix_TOT)

      ! Initialize I_tot
      I_tot = 0.0d0

      ! q_loop_0
      do grain_i = 1, num_SOL
        I_tot(0)  = I_tot(0) + F_CG_TOT(0,grain_i)**2
        do grain_j = grain_i+1, num_SOL
          I_tot(0)  = I_tot(0) + 2 * F_CG_TOT(0,grain_i) * F_CG_TOT(0,grain_j)
#ifdef DEBUG_NAN
          if ( isNaN( I_tot(0) )) then
            STOP 'Detected NaN'
          end if
#endif
        end do
      end do

      q_loop: do q = 1 , num_points - 1
        do grain_i = 1, num_SOL
          ! Add diagonal term (i,i) once
          I_tot(q)  = I_tot(q) + F_CG_TOT(q,grain_i) **2
	  ! Add half non-diagonal terms twice
          do grain_j = grain_i+1, num_SOL
            I_tot(q)  = I_tot(q) + 2 * F_CG_TOT(q,grain_i) * F_CG_TOT(q,grain_j) * &
           & sin(DistanceMatrix_TOT(grain_j,grain_i) * q * delta_q) / &
           & (q * delta_q * DistanceMatrix_TOT(grain_j,grain_i))
#ifdef DEBUG_NAN
          if ( isNaN( I_tot(q) )) then
            STOP 'Detected NaN'
          end if
#endif
          end do
        end do
      end do q_loop

      ! Deallocate everything
      deallocate(F_CG_TOT, AtomNames_TOT, pos_SOL, DistanceMatrix_TOT)

      ! Log10 everything
      I_tot(0 : num_points - 1) = log10(I_tot(0 : num_points - 1))
      return

    end function fct_generate_reference_SAXS_curve

    subroutine write_SAXS_curve_to_file(curve1, file_name)
      implicit none
      real*8, dimension(0 : max_q_point - 1), intent(in) :: curve1
      character*360, intent(in) :: file_name
      integer :: q_point

      !print *, 'file_name : ', file_name
!      open(unit=321, file=trim(file_name), action='write',position='append')
      open(61,file=file_name,action='write',position='append')

      do q_point = 0, max_q_point - 1
        if (linear_intensity) then
          write (321,'(f8.3 ES15.7)') q_point*delta_q, 10**curve1(q_point)
        else
          write (61,'(f8.3 ES15.7)') q_point*delta_q, curve1(q_point)
        end if
      end do
    
      write (61, *), 'MODEL_SAXS'
      close(321)

    end subroutine write_SAXS_curve_to_file

    subroutine write_SAXS_curve_to_unit(curve1, unit_number)
      implicit none
      real*8, dimension(0 : max_q_point - 1), intent(in) :: curve1
      integer, intent(in) :: unit_number
      integer :: q_point

      do q_point = 0, max_q_point - 1
        if (isNaN(curve1(q_point))) then
          print *, curve1
          print *, 'q_point: ', q_point
          STOP 'NaN Error'
        end if
       if (linear_intensity) then
         write (unit_number,'(f8.3 ES15.7)') q_point*delta_q, 10**curve1(q_point)
       else
         write (unit_number,'(f8.3 ES15.7)') q_point*delta_q, curve1(q_point)
       end if
      end do
      write (unit_number,*) ' '
    
    end subroutine write_SAXS_curve_to_unit

    ! Compute the appropriate norm using SAXS_norm_type
    function norm_curves (curve1, curve2) result(norm)
      implicit none
      real*8, dimension(0 : max_q_point - 1) :: curve1, curve2
      real*8 :: norm
      select case (SAXS_norm_type)
        case (1)
          norm = norm1_curves(curve1, curve2)
        case (2)
          norm = norm2_curves(curve1, curve2)
        case (3)
          norm = norm_R_curves(curve1, curve2)
        case default
          STOP 'Undefined norm type. Aborting.'
          norm = 0.0d0
      end select
    end function norm_curves


    !> @brief Straightforward, norme-2 distance computation between two curves.
    function norm2_curves( curve1, curve2 ) result(norm)
      implicit none
      integer :: q
      real*8, dimension(0 : max_q_point - 1) :: curve1, curve2
      real*8 :: norm

      norm = 0.0d0
      do q = 1, max_q_point - 1
        norm = norm + ((10**curve1(q) - 10**curve2(q)) / (q * delta_q))**2
      end do
      norm = norm / ( max_q_point * (10**curve1(0))**2 ) ! NORMALIZATION
      return
    end function norm2_curves

    !> @brief Straightforward, norme-1 distance computation between two curves.
    function norm1_curves( curve1, curve2 ) result(norm)
      implicit none
      integer :: q
      real*8, dimension(0:max_q_point-1) :: curve1, curve2
      real*8 :: norm

      norm = 0.0d0
      do q = 0, max_q_point - 1
        norm = norm + dabs( curve1(q) - curve2(q) )
      end do

      norm = norm / max_q_point ! NORMALIZATION
      return
    end function norm1_curves

    !> @brief Straightforward, infinity-norme distance computation between two curves.
    function norm_R_curves( curve1, curve2 ) result(norm)
      implicit none
      integer :: q
      real*8, dimension(0:max_q_point-1) :: curve1, curve2
      real*8 :: norm, norm_num, norm_den, sc, sc_num, sc_den

      norm_num = 0.0d0
      norm_den = 0.0d0
      sc_num = 0.0d0
      sc_den = 0.0d0

     !do q = 1, max_q_point - 1
     !  sc_num = sc_num + ( q * delta_q )**2 * 10**curve1(q) * 10**curve2(q) 
     !  sc_den = sc_den + ( q * delta_q )**2 * ( 10**curve1(q) )**2 
     !end do

     !sc = sc_num / sc_den
      sc = 1 ! Watch out for scale factor

      do q = 1, max_q_point - 1
        norm_num = norm_num + ( q * delta_q * ( sc * 10**curve1(q) - 10**curve2(q) ) )**2
        norm_den = norm_den + ( q * delta_q )**2 * sc * 10**curve1(q) * 10**curve2(q) 
      end do

      norm = norm_num / norm_den 

      return
    end function norm_R_curves


    !> @brief Used to combine two set of coordinates to produce a third one
    !> by linear, symetric mixing of every coordinates.
    subroutine mix_coords(XCoords1, XCoords2, XCoords3, increment_pop_count)
      implicit none
      logical, intent(in) :: increment_pop_count
      real*8, dimension(1:3*num_atoms), intent(in) :: XCoords1, XCoords2
      real*8, dimension(1:3*num_atoms), intent(out) :: XCoords3

      XCoords3 = 0.5d0 * (XCoords1 + XCoords2)

      if (increment_pop_count) population_count = population_count + 1
    end subroutine mix_coords


    !> @brief Same as mix_coords, but is a function instead of being a subroutine.
    function fct_mix_coords(XCoords1, XCoords2, increment_pop_count) result(XCoords3)
      implicit none
      logical :: increment_pop_count
      real*8, dimension(1:3*num_atoms) :: XCoords1, XCoords2
      real*8, dimension(1:3*num_atoms) :: XCoords3

      XCoords3 = 0.5d0 * (XCoords1 + XCoords2)

      if (increment_pop_count) population_count = population_count + 1

      return
    end function fct_mix_coords


    !> @brief Quicksort algorithm on conf%score.
    !> Taken from http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#Fortran
    recursive subroutine QSort_score(a,na)
      use defs

      ! DUMMY ARGUMENTS
      integer, intent(in) :: nA
      type (t_conformations), dimension(nA), intent(in out) :: A

      ! LOCAL VARIABLES
      integer :: left, right
      real*8 :: random
      real*8 :: pivot
      type (t_conformations) :: temp
      integer :: marker

          if (nA > 1) then

              call random_number(random)
              pivot = A(int(random*dble(nA-1))+1)%score   ! random pivor (not best performance, but avoids worst-case)
              left = 0
              right = nA + 1

              do while (left < right)
                  right = right - 1
                  do while (A(right)%score > pivot)
                      right = right - 1
                  end do
                  left = left + 1
                  do while (A(left)%score < pivot)
                      left = left + 1
                  end do
                  if (left < right) then
                    temp = A(left)
                    A(left) = A(right)
                    A(right) = temp
                  end if
              end do

              if (left == right) then
                  marker = left + 1
              else
                  marker = left
              end if

              call QSort_score(A(1:marker-1),marker-1)
              call QSort_score(A(marker:nA),nA-marker+1)

          end if

    end subroutine QSort_score


    !> @brief Bubble algorithm on conf%score.
    !> Taken from http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort#Fortran
    subroutine BubbleSort_score(A, nA)
      use defs

      ! DUMMY ARGUMENTS
      integer, intent(in) :: nA
      type(t_conformations), dimension(nA), intent(in out) :: A

      INTEGER :: i, j
      LOGICAL :: swapped = .TRUE.
      type(t_conformations) :: temp

      DO j = nA-1, 1, -1
        swapped = .FALSE.
        DO i = 1, j
          IF (a(i)%score > a(i+1)%score) THEN
            temp = a(i)
            a(i) = a(i+1)
            a(i+1) = temp
            swapped = .TRUE.
          END IF
        END DO
        IF (.NOT. swapped) EXIT
      END DO
    end subroutine BubbleSort_score

    !> @brief (Re)generates corrected Form Factors for grains.
    !> @warning When multiple threads are launch on the same machine, there seem to be
    !> overwriting problems between them rendering the files corrupted.
    !> To be looked into.
    subroutine gen_corrected_CG_structureFactors()
      use hash_int
      implicit none

      integer :: grain_i, point, solvent_grain_hash
      logical :: file_exists
      character*100 :: corrected_dat_file, uncorrected_dat_file
      real*8 :: V_i, q, F_q

      call hash_get(solvent_name, solvent_grain_hash)

      regen_corrected_CG_FF: do grain_i=1, grain_number
        ! For each grain ...
        corrected_dat_file ='dat/ff' // trim(Grains(grain_i)) // '.cor.awk.dat'
        inquire(file=corrected_dat_file, exist=file_exists)
        regen: if ( (.not. file_exists) .or. regen_corrected_FF ) then
          ! If the corrected file doesn't exist, or if we force regeneration ...
          uncorrected_dat_file = 'dat/ff' // trim(Grains(grain_i)) // '.awk.dat'
          open(unit=18, file=corrected_dat_file, form='formatted')
          is_solvent: if (Grains_electron_density(grain_i) /= 0.0d0) then
            is_not_outer_shell: if (Grains(grain_i)(1:4) .eq. solvent_name) then
              open(unit=17, file=uncorrected_dat_file, status='old')
              ! Don't correct the solvent !
              q_loop_1: do point = 0, num_points - 1
                read(17,'(F8.3 F10.8)') q, F_q
                write(18,'(F8.3 F13.8)') q, F_q
              end do q_loop_1
            else ! Is outer shell
              uncorrected_dat_file =  'dat/ff' // trim(solvent_name) // '.awk.dat'
              open(unit=17, file=uncorrected_dat_file, status='old')
              ! Scale up the outer shell FF with solvent_contrast
              q_loop_2: do point = 0, num_points - 1
                read(17,'(F8.3 F10.8)') q, F_q
                write(18,'(F8.3 F13.8)') q, F_q * solvent_contrast
              end do q_loop_2
              uncorrected_dat_file = 'dat/ff' // trim(Grains(grain_i)) // '.awk.dat'
              print *, 'Running : ', 'cp ' // trim(corrected_dat_file) // ' ' // trim(uncorrected_dat_file)
              call system('cp ' // trim(corrected_dat_file) // ' ' // trim(uncorrected_dat_file) )
            end if is_not_outer_shell
          else ! Is not solvent
            open(unit=17, file=uncorrected_dat_file, status='old')
            !V_i = (4.0/3.0) * 3.14159 * Grains_Radii(grain_i)**3
            V_i = Grains_ExcludedVol(grain_i)
            q_loop_3: do point = 0, num_points - 1
              read(17,'(F8.3 F10.8)') q, F_q
              write(18,'(F8.3 F13.8)') q, F_q - V_i * Grains_electron_density(solvent_grain_hash) * &
                exp( -V_i**(2.0/3) * q**2 / (4.0 * 3.141592653589) )
            end do q_loop_3
          end if is_solvent
          close(18)
          close(17)
        end if regen
      end do regen_corrected_CG_FF

    end subroutine gen_corrected_CG_structureFactors


    !> @brief Used to speed-up calculation by storing distances between all atoms (time-memory trade-off).
    subroutine fill_half_distance_matrix(num_grain,pos,DistanceMatrix)

      implicit none
      integer, intent(in) :: num_grain
      integer :: i,j
      real*8, dimension(1:num_grain,1:num_grain), intent(out) :: DistanceMatrix
      real*8, dimension(1:3*num_grain) ::  pos
      real*8 :: r_ij

      DistanceMatrix=0.d0
      i_loop: do i=1,num_grain
        j_loop: do j=i+1,num_grain
          r_ij = sqrt((pos(3*i-2)-pos(3*j-2))**2+(pos(3*i-1)-pos(3*j-1))**2+(pos(3*i)-pos(3*j))**2)
          DistanceMatrix(i,j)=r_ij
          DistanceMatrix(j,i)=r_ij
        end do j_loop
      end do i_loop
      
    end subroutine fill_half_distance_matrix

    subroutine getLineNumFromUnit_RemoveComments(nf, line_number)
      implicit none

      integer, intent(in) :: nf
      integer,intent(out) :: line_number

      character*100 line
      integer :: stat

      line_number = 0
      do
        read(nf,'(a)',iostat=stat) line
        if (stat /= 0) exit
        if ( line(1:1) /= comment_pattern ) then
          line_number = line_number + 1
        end if
      end do

      return
    end subroutine getLineNumFromUnit_RemoveComments

    !> @brief Main hydration routine. Interesting parameters (dx, n_shells) are module variables that can be
    !> modified with care (being careful of the dx**3 dependance of the algorithm ...)
    !> @details We rely heavily on arrays to speed up computations.
    subroutine hydrate_pos_outer_shell(XCoords, AtomNames, num_SOL, Xcoords_SOL)

      use defs, only: use_qbug
      implicit none

      real*8, intent(in), dimension(1:3*num_atoms) :: XCoords
      character*5, intent(in), dimension(1:num_atoms) :: AtomNames
      real*8, dimension(1:num_atoms) :: CutoffArrayInternal_pow2, CutoffArrayExternal_pow2
      integer, intent(out) :: num_SOL
      real*8, intent(out), dimension(1:3*MAXSOL) :: XCoords_SOL

      integer :: lattice_x,lattice_y,lattice_z

      integer :: atom_i

      real*8 :: r_ij
      real*8 :: x,y,z
      real*8 :: cut_off_internal_2, cut_off_external_2
      real*8, dimension(1:6) :: MinMaxCoordsArray
      integer, dimension(1:6) :: latticeArray

      integer :: contact_num

      integer :: pdb_res_num, pdb_atom_num

!#ifdef DEBUG_HYD
if (use_qbug) then 
      open(unit=222,file=trim(saxs_input_file) // '_hyd.pdb', form='formatted')
      pdb_res_num = 1
      pdb_atom_num = 1
!#endif
endif

      ! Fill the cutoff array with the value of each grain
      call fill_cutoff_array(AtomNames, CutoffArrayInternal_pow2, CutoffArrayExternal_pow2)

      ! Compute dimension of the box ! Format of the array : (/minX,minZ,minZ,maxX,maxY,maxZ/)
      call box_dimensions(XCoords, MinMaxCoordsArray, sqrt( maxval(CutoffArrayExternal_pow2,num_atoms))  ) 

      !Compute max dimensions for the x,y,z loops
      latticeArray = int(MinMaxCoordsArray/dx)

      ! (Re)Initialize num_SOL
      num_SOL = 0

      x_loop: do lattice_x=latticeArray(1), latticeArray(2)
        x = lattice_x*dx
        y_loop: do lattice_y=latticeArray(3), latticeArray(4)
          y = lattice_y*dx
          z_loop: do lattice_z=latticeArray(5), latticeArray(6)
            z = lattice_z*dx
            contact_num = 0
            ! Ensure that there are no atoms within a given cut-off radius
            atom_loop: do atom_i=1,num_atoms
              cut_off_internal_2 = CutoffArrayInternal_pow2(atom_i)
              cut_off_external_2 = CutoffArrayExternal_pow2(atom_i)
              r_ij = (XCoords(3*atom_i-2)-x)**2
              if ( r_ij <= cut_off_external_2 ) then
                r_ij = r_ij + (XCoords(3*atom_i-1)-y)**2
                if ( r_ij <= cut_off_external_2 ) then
                  r_ij= r_ij + (XCoords(3*atom_i)-z)**2
                  ! If clash, abort adding procedure
                  clash: if(r_ij <= cut_off_internal_2 ) then
                    contact_num = 0
                    exit
                  end if clash
                  contact: if (r_ij <= cut_off_external_2 ) then
                    contact_num = contact_num + 1
                  end if contact
                end if
              end if
            end do atom_loop
            add: if (contact_num /= 0 ) then
               num_SOL = num_SOL + 1
               XCoords_SOL(3*num_SOL -2) = x
               XCoords_SOL(3*num_SOL -1) = y
               XCoords_SOL(3*num_SOL   ) = z
!#ifdef DEBUG_HYD
if (use_qbug) then
               write (222,'(a6,i5,a1,a4,a1,a3,a2,i4,a4,3f8.3)') &
                 'ATOM  ',pdb_atom_num,' ', 'HOH', ' ', 'SOL', ' A', pdb_res_num,'    ', x,y,z
               pdb_atom_num = merge(pdb_atom_num + 1,1,pdb_atom_num .lt. 99999) ! Enforce that pdb_atom_num doesn't get past 99999 via ternary operator
               pdb_res_num = merge(pdb_res_num + 1,1,pdb_res_num .lt. 9999) ! Enforce that pdb_res_num doesn't get past 9999 via ternary operator
!#endif
endif
            end if add
          end do z_loop
        end do y_loop
      end do x_loop

!#ifdef DEBUG_HYD
if (use_qbug) then !lm759
      PRINT *, " "
      PRINT *, " "
      PRINT *, "Water radius: ", dx / 2.0
      PRINT *, "Water contrast: ", SAXS_w_shell
      PRINT *, "Number of shell atoms: ", num_SOL
      PRINT *, " "
      PRINT *, "Water box: ", MinMaxCoordsArray
      PRINT *, " "
      close(222)
!#endif
endif

    end subroutine hydrate_pos_outer_shell

    subroutine debug_pos_fill(XCoords, AtomNames)
      implicit none
      real*8, intent(in), dimension(1:3*num_atoms) :: XCoords
      character*5, intent(in), dimension(1:num_atoms) :: AtomNames
      character*5, dimension(1:MAXSOL) :: AtomNames_SOL
      real*8, dimension(3*MAXSOL) :: pos_SOL
      integer :: num_SOL, atom_sol
      integer :: pdb_res_num, pdb_atom_num

      call hydrate_pos_fill(XCoords, AtomNames, num_SOL, pos_SOL, AtomNames_SOL)

      open(unit=222,file =  &
        saxs_input_file(1:len_trim(saxs_input_file)-4) // &
        '_hyd_fill.pdb', form='formatted')
      pdb_res_num = 1
      pdb_atom_num = 1

      do atom_sol=1,num_SOL
        write (222,'(a6,i5,a1,a4,a1,a3,a2,i4,a4,3f8.3)') &
          'ATOM  ',pdb_atom_num,' ', 'HOH', ' ', 'SOL', ' A', pdb_res_num,'    ', &
          pos_SOL(3*atom_sol-2), pos_SOL(3*atom_sol-1), pos_SOL(3*atom_sol)
        pdb_atom_num = merge(pdb_atom_num + 1,1,pdb_atom_num .lt. 99999) ! Enforce that pdb_atom_num doesn't get past 99999 via ternary operator
        pdb_res_num = merge(pdb_res_num + 1,1,pdb_res_num .lt. 9999) ! Enforce that pdb_res_num doesn't get past 9999 via ternary operator
      end do

      close(222)

    end subroutine debug_pos_fill


    !> @brief Same as hydrate_pos_outer_layer, but also contains the 'inside'/filling of the molecule
    !> (the solvent molecules in contact, as defined by the inner_cutoff_radius)
    ! TODO : Implement different AtomNames for bulk and outer shell ...
    subroutine hydrate_pos_fill(XCoords, AtomNames, num_SOL, Xcoords_SOL, AtomNames_SOL)
      use defs, only: use_qbug

      implicit none

      real*8, intent(in), dimension(1:3*num_atoms) :: XCoords
      character*5, intent(in), dimension(1:num_atoms) :: AtomNames
      real*8, dimension(1:num_atoms) :: CutoffArrayInternal_pow2, CutoffArrayExternal_pow2
      integer, intent(out) :: num_SOL
      real*8, intent(out), dimension(1:3*MAXSOL) :: XCoords_SOL
      character*5, intent(inout), dimension(1:MAXSOL) :: AtomNames_SOL

      integer :: lattice_x,lattice_y,lattice_z

      integer :: atom_i

      real*8 :: r_ij
      real*8 :: x,y,z
      real*8 :: cut_off_internal_2, cut_off_external_2
      real*8, dimension(1:6) :: MinMaxCoordsArray
      integer, dimension(1:6) :: latticeArray
      character*4 :: atom_name

      logical :: clash, contact, should_add

      integer :: pdb_res_num, pdb_atom_num

!#ifdef DEBUG_HYD
if (use_qbug) then
      open(unit=222,file =  &
        saxs_input_file(1:len_trim(saxs_input_file)-4) // &
        '_hyd_fill.pdb', form='formatted')
      pdb_res_num = 1
      pdb_atom_num = 1
!#endif
endif

      ! Fill the cutoff array with the value of each grain
      call fill_cutoff_array(AtomNames, CutoffArrayInternal_pow2, CutoffArrayExternal_pow2)

      ! Compute dimension of the box ! Format of the array : (/minX,minZ,minZ,maxX,maxY,maxZ/)
      call box_dimensions(XCoords, MinMaxCoordsArray, sqrt( maxval(CutoffArrayExternal_pow2,num_atoms)) ) 

      !Compute max dimensions for the x,y,z loops
      latticeArray = int(MinMaxCoordsArray/dx)

      ! (Re)Initialize num_SOL
      num_SOL = 0

      x_loop: do lattice_x=latticeArray(1), latticeArray(2)
        x = lattice_x*dx
        y_loop: do lattice_y=latticeArray(3), latticeArray(4)
          y = lattice_y*dx
          z_loop: do lattice_z=latticeArray(5), latticeArray(6)
            z = lattice_z*dx
            clash = .false.
            contact = .false.
            ! Ensure that there are no atoms within a given cut-off radius
            atom_loop: do atom_i=1,num_atoms
              cut_off_internal_2 = CutoffArrayInternal_pow2(atom_i)
              cut_off_external_2 = CutoffArrayExternal_pow2(atom_i)
              r_ij = (XCoords(3*atom_i-2)-x)*(XCoords(3*atom_i-2)-x)
              if ( r_ij <= cut_off_external_2 ) then
                r_ij = r_ij + (XCoords(3*atom_i-1)-y)*(XCoords(3*atom_i-1)-y)
                if ( r_ij <= cut_off_external_2 ) then
                  r_ij= r_ij + (XCoords(3*atom_i)-z)*(XCoords(3*atom_i)-z)
                  if_clash: if(r_ij <= cut_off_internal_2 ) then
                    clash = .true.
                    atom_name = 'HOH '
                    exit
                  end if if_clash
                  if_contact: if (r_ij <= cut_off_external_2 ) then
                    contact = .true.
                    atom_name = 'HOHo'
                  end if if_contact
                end if
              end if
            end do atom_loop
            should_add = clash .or. (contact .and. refine_hydration_layer )
            add: if (should_add ) then
               num_SOL = num_SOL + 1
               XCoords_SOL(3*num_SOL -2) = x
               XCoords_SOL(3*num_SOL -1) = y
               XCoords_SOL(3*num_SOL   ) = z
               AtomNames_SOL(num_sol) = atom_name
!#ifdef DEBUG_HYD
if (use_qbug) then
               write (222,'(a6,i5,a1,a4,a1,a3,a2,i4,a4,3f8.3)') &
                 'ATOM  ',pdb_atom_num,' ', atom_name, ' ', 'SOL', ' A', pdb_res_num,'    ', x,y,z
               pdb_atom_num = merge(pdb_atom_num + 1,1,pdb_atom_num .lt. 99999) ! Enforce that pdb_atom_num doesn't get past 99999 via ternary operator
               pdb_res_num = merge(pdb_res_num + 1,1,pdb_res_num .lt. 9999) ! Enforce that pdb_res_num doesn't get past 9999 via ternary operator
!#endif
endif
            end if add
          end do z_loop
        end do y_loop
      end do x_loop

!#ifdef DEBUG_HYD
if (use_qbug) close(222)
!#endif

    end subroutine hydrate_pos_fill

    ! Format of the array : (/minX,minZ,minZ,maxX,maxY,maxZ/)
    subroutine box_dimensions(XCoords, MinMaxCoordsArray, padding_length)

      use defs, only: use_qbug
      implicit none
      real*8,intent(in) :: padding_length ! In nm

      integer :: atom_i
      real*8,dimension(1:6),intent(out) ::  MinMaxCoordsArray
      real*8  XCoords(3*num_atoms)
      integer :: i

      ! lm759 Straight and simple fortran functions to make sure it works
      MinMaxCoordsArray=(/ Minval(XCoords(::3)), Maxval(XCoords(::3)), &
      & Minval(XCoords(2::3)), Maxval(XCoords(2::3)), &
      & Minval(XCoords(3::3)), Maxval(XCoords(3::3)) /)

      ! Init the array 
      ! PDB is limited to 3 digits before the dot, so [-1000..1000] is the range
     ! MinMaxCoordsArray=(/1000.0,-1000.0,1000.0,-1000.0,1000.0,-1000.0/)
     ! do atom_i=1,num_atoms ! This algoritm DOES NOT always WORK ! lm759
     !   ! Unrolling manually for performance
     !   if ( XCoords(atom_i*3-2) <= MinMaxCoordsArray(1) ) then   !X_min
     !     MinMaxCoordsArray(1) = XCoords(atom_i*3-2)
     !   else if ( XCoords(atom_i*3-2) >= MinMaxCoordsArray(2) ) then !X_max
     !     MinMaxCoordsArray(2) = XCoords(atom_i*3-2)
     !   end if
     !   if ( XCoords(atom_i*3-1) <= MinMaxCoordsArray(3) ) then   !Y_min
     !     MinMaxCoordsArray(3) = XCoords(atom_i*3-1)
     !   else if ( XCoords(atom_i*3-1) >= MinMaxCoordsArray(4) ) then !Y_max
     !     MinMaxCoordsArray(4) = XCoords(atom_i*3-1)
     !   end if
     !   if ( XCoords(atom_i*3) <= MinMaxCoordsArray(5) ) then   !Z_min
     !     MinMaxCoordsArray(5) = XCoords(atom_i*3)
     !   else if ( XCoords(atom_i*3) >= MinMaxCoordsArray(6) ) then !Z_max
     !     MinMaxCoordsArray(6) = XCoords(atom_i*3)
     !   end if
     ! end do

      ! Pad by padding_length nm in every direction, just to be safe
      ! Warning : this value should be modified for really big coarse grained solvent molecule
      do i=1,6
        ! Substract padding_length to mins, adds it to maxs
        MinMaxCoordsArray(i) = merge(MinMaxCoordsArray(i)-padding_length, MinMaxCoordsArray(i)+padding_length, &
        & modulo(i,2) == 1)
      end do

      return

    end subroutine box_dimensions


    !> @brief Initializes the grain array with Form factors : F_grains
    subroutine init_hash_CG()
      use defs, only: use_qbug
      use hash_int
      implicit none
      integer :: grain_i, q
      real*8 :: bufferValue, bufferValue2, bufferValue3, bufferValue4, temp
      character*180 :: datFile, parameter_line
      character*5 :: bufferKey
      integer :: NF=18
      integer :: grain_hash_num, stat

      !Get grain number from parameter_file (either SAXS_grains.dat or SAXS_atoms.dat)
      open(unit=NF, file=parameter_file, status="old")
      get_grain_number: do
        read(NF,'(a)', iostat=stat) parameter_line
        if (stat /= 0) exit
        if (parameter_line(1:1) /= comment_pattern) grain_number = grain_number + 1
      end do get_grain_number
      close(NF)

      allocate(Grains(1:grain_number))
      allocate(F_grains(0 : num_points - 1, 1 : grain_number))
      allocate(Grains_cutoff(1:grain_number))

      ! Make the hash with the grain names from parameter_file (either SAXS_grains.dat or SAXS_atoms.dat)
      call hash_init()
      open(unit=NF, file=parameter_file, status="old")
      grain_i = 1
      build_grain_hash: do while (grain_i <= grain_number)
        read(nf,'(a)',iostat=stat) parameter_line
        if (parameter_line(1:1) /= comment_pattern) then
          read(parameter_line,'(a5)') bufferKey
          call hash_set(bufferKey, grain_i)
          Grains(grain_i)=bufferKey
          grain_i = grain_i + 1
        end if
      end do build_grain_hash
      close(NF)

      allocate(Grains_excludedRadii(1:grain_number), &
        Grains_excludedVol(1:grain_number), Grains_electron_density(1:grain_number) )

      ! Fill the arrays : Grains_cutoff, Grains_excludedRadii, Grains_excludedVol and Grains_electron_density
      open(unit=NF, file=parameter_file, status="old")
      grain_i = 1
      build_grain_arrays: do while (grain_i <= grain_number)
        read (nf, '(a)'), parameter_line
        if (parameter_line(1:1) /= comment_pattern) then
          read(parameter_line,'(a5 f4.1 f4.1 f6.1 f6.1 x a1)') &
            bufferKey, bufferValue, bufferValue2, bufferValue3, bufferValue4
          call hash_get(bufferKey, grain_hash_num)
          Grains_excludedRadii(grain_hash_num) = bufferValue
          Grains_cutoff(grain_hash_num) = bufferValue2
          Grains_excludedVol(grain_hash_num) = bufferValue3
          Grains_electron_density(grain_hash_num) = bufferValue4
          get_solvent_contrast: if (bufferKey .eq. solvent_name(1:3) // 'o' ) then
            call hash_get(solvent_name, grain_hash_num)
            if (grain_hash_num .eq. 0 ) STOP 'Must put solvent before outer solvent in SAXS_grains.dat. Aborting.'
            solvent_contrast = bufferValue4 / Grains_electron_density(grain_hash_num)
          end if get_solvent_contrast
          grain_i = grain_i + 1
        end if
      end do build_grain_arrays
      close(NF)

      ! Generate corrected Form Factors
      if_regen_corrected_CG_FF: if (regen_corrected_FF) then
        call gen_corrected_CG_structureFactors()
      endif if_regen_corrected_CG_FF

      ! Build F_grains from the dat/ff* files
      read_dat_files: do grain_i=1, grain_number
        ! Depending on whether or not we are doing the calculation in solvent, we either take the corrected
        ! or the untouched Form Factors
        if ( in_solution_curve .and. .not. explicit_sol_contribution ) then
          datFile= 'dat/ff' // trim(Grains(grain_i)) // '.cor.awk.dat' ! Solvent-corrected FF
        else
          datFile= 'dat/ff' // trim(Grains(grain_i)) // '.awk.dat' ! In vacuo FF
        end if
        open(unit=NF, file=datFile, status='old')
        copy_q: do q=0, num_points - 1
          read(NF,'(F8.3 F10.8)') temp, F_grains(q, grain_i)
        end do copy_q
        close(NF)
        ! Added by lm759 to tune excess electron density of the hydration shell
        if ( trim(Grains(grain_i)) .eq. 'HOH' ) then
          F_grains(:, grain_i) = SAXS_w_shell * F_grains(:, grain_i) 
          if (use_qbug) PRINT *, "WATER FORM FACTOR IN ZERO: ", F_grains(0,grain_i)
        endif
      end do read_dat_files

    end subroutine init_hash_CG


    !> @brief Initializes the grain array with Form factors : F_grains
    subroutine init_hash_FA()
      use hash_int
      implicit none
      integer :: grain_i, q_point
      real*8 :: bufferValue, bufferValue2, V_i, q
      character*180 :: parameter_line
      character*5 :: bufferKey
      integer :: NF=18
      integer :: grain_hash_num, stat
      ! Cromer-Mann parameters
      real*8 :: a1, a2, a3, a4, c, b1, b2, b3, b4

      !Get grain number from parameter_file (either SAXS_grains.dat or SAXS_atoms.dat)
      open(unit=NF, file=parameter_file, status="old")
      get_grain_number: do
        read(NF,'(a)', iostat=stat) parameter_line
        if (stat /= 0) exit
        if (parameter_line(1:1) /= comment_pattern) grain_number = grain_number + 1
      end do get_grain_number
      close(NF)

      allocate(Grains(1:grain_number))
      allocate(F_grains(0:num_points-1, 1:grain_number))
      allocate(Grains_cutoff(1:grain_number), Grains_excludedRadii(1:grain_number), Grains_excludedVol(1:grain_number), &
        Grains_electron_density(1:grain_number) )

      ! Make the hash with the grain names from parameter_file (either SAXS_grains.dat or SAXS_atoms.dat)
      call hash_init()
      open(unit=NF, file=parameter_file, status="old")
      grain_i = 1
      build_grain_hash: do while (grain_i <= grain_number)
        read(nf,'(a)',iostat=stat) parameter_line
        if (parameter_line(1:1) /= comment_pattern) then
          read(parameter_line,'(a5)'), bufferKey
          call hash_set(bufferKey, grain_i)
          Grains(grain_i)=bufferKey
          grain_i = grain_i + 1
        end if
      end do build_grain_hash
      close(NF)

      ! Fill the arrays : Grains_cutoff, Grains_excludedRadii, Grains_excludedVol and Grains_electron_density
      open(unit=NF, file=parameter_file, status="old")
      grain_i = 1
      build_grain_arrays: do while (grain_i <= grain_number)
        read (nf, '(a)') parameter_line
        if (parameter_line(1:1) /= comment_pattern) then
          read(parameter_line,'(a5 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f4.1 f6.2)',iostat=stat) &
            bufferKey, a1, a2, a3, a4, c, b1, b2, b3, b4, bufferValue, bufferValue2
          print '(a5 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f10.6 f4.1 f6.2)', &
            bufferKey, a1, a2, a3, a4, c, b1, b2, b3, b4, bufferValue, bufferValue2
          call hash_get(bufferKey, grain_hash_num)
          Grains_cutoff(grain_hash_num) = bufferValue
          Grains_excludedVol(grain_hash_num) = bufferValue2
          compute_q: do q_point=0,num_points-1
            q = q_point * delta_q
            implicit_correct_form_factors: if ( in_solution_curve .and. .not. explicit_sol_contribution ) then
              V_i = Grains_excludedVol(grain_hash_num)
              F_grains(q_point, grain_i) = c + a1*EXP(-b1*(q**2)/157.91d0) + a2*EXP(-b2*(q**2)/157.91d0) + &
                                               a3*EXP(-b3*(q**2)/157.91d0) + a4*EXP(-b4*(q**2)/157.91d0) - &
                   V_i * solvent_electron_density * exp( -V_i**(2.0/3) * q**2 / (4.0 * 3.141592653589) )
            else
              F_grains(q_point, grain_i) = c + a1*EXP(-b1*(q**2)/157.91d0) + a2*EXP(-b2*(q**2)/157.91d0) + &
                                               a3*EXP(-b3*(q**2)/157.91d0) + a4*EXP(-b4*(q**2)/157.91d0)
            end if implicit_correct_form_factors
          end do compute_q
          grain_i = grain_i + 1
        end if
      end do build_grain_arrays
      close(NF)

    end subroutine init_hash_FA


    subroutine fill_structureFactor_array(num_grain, GrainName, F_q_CG)
      implicit none
      integer, intent(in) :: num_grain
      character*5, intent(in), dimension(1:num_grain) :: GrainName
      real*8, intent(out),dimension(0:num_points-1, 1:num_grain ) :: F_q_CG

      if (coarse_grained) then
        call fill_CG_structureFactor_array(num_grain, GrainName, F_q_CG)
      else
        call fill_FA_structureFactor_array(num_grain, GrainName, F_q_CG)
      end if

    end subroutine fill_structureFactor_array

    !> @brief Fills a F_q_CG array with FF values from F_grains
    subroutine fill_CG_structureFactor_array(num_grain, GrainName, F_q_CG)

      use hash_int
      implicit none

      integer, intent(in) :: num_grain
      character*5, intent(in), dimension(1:num_grain) :: GrainName
      real*8, intent(out),dimension(0:num_points-1, 1:num_grain ) :: F_q_CG

      integer :: grain_hash_num
      integer :: grain_i

      ! Finally, fill the array accordingly
      match_cutoff: do grain_i=1,num_grain
        call hash_get( adjustl(trim(GrainName(grain_i))) , grain_hash_num )
        if (grain_hash_num /= 0 ) then
          F_q_CG(0:num_points-1, grain_i) = F_grains(0:num_points-1, grain_hash_num)
        else
          print *, "Couldn't find structure factor parameters for Grain : "
          print '(i5 a)', grain_i, GrainName(grain_i)
          F_q_CG(0:num_points-1, grain_i) = 0.0
          STOP 5
        end if
      end do match_cutoff

    end subroutine fill_CG_structureFactor_array


    !> @brief Fills a F_q_CG array with FF values from F_grains
    subroutine fill_FA_structureFactor_array(num_grain, GrainName, F_q_CG)

      use hash_int
      implicit none

      integer, intent(in) :: num_grain
      character*5, intent(in), dimension(1:num_grain) :: GrainName
      character*3 :: atom
      real*8, intent(out),dimension(0:num_points-1, 1:num_grain ) :: F_q_CG

      integer :: grain_hash_num
      integer :: grain_i

      ! Finally, fill the array accordingly
      match_cutoff: do grain_i=1,num_grain
        atom = adjustl(trim(GrainName(grain_i))) ! TODO : Might contain error (for instance, OH2 -> H, not O)
        if (atom(1:1) .eq. 'O') then
          if (atom(3:3) .eq. 'P') then
            ! Account for phosphate's negatively charged oxygen atoms
            atom = 'O-'
          else
            atom = atom(1:1)
          end if
        else
          atom = atom(1:1)
        end if
        call hash_get( atom(1:2) , grain_hash_num )
        if (grain_hash_num /= 0 ) then
          F_q_CG(0:num_points-1, grain_i) = F_grains(0:num_points-1, grain_hash_num)
        else
          print *, "Couldn't find structure factor parameters for Grain : "
          print '(i5 a a )', grain_i, ' ', atom
          F_q_CG(0:num_points-1, grain_i) = 0.0
          STOP 5
        end if
      end do match_cutoff

    end subroutine fill_FA_structureFactor_array


    subroutine fill_cutoff_array(AtomNames, CutoffArrayInternal_pow2, CutoffArrayExternal_pow2)

      use hash_int
      use defs, only: use_qbug
      implicit none

      character*5, intent(in), dimension(1:num_atoms) :: AtomNames
      real*8, dimension(1:num_atoms), intent(out) :: CutoffArrayInternal_pow2
      real*8, dimension(1:num_atoms), intent(out) :: CutoffArrayExternal_pow2

      integer :: atom_i, grain_hash_num
      character*5 :: atom_name

      ! Finally, fill the cutoff array accordingly, using * as the unknown value
      match_cutoff: do atom_i=1,num_atoms
          if (coarse_grained) then
            atom_name = trim(AtomNames(atom_i))
          else
            atom_name(1:5) = adjustl(AtomNames(atom_i))
            atom_name(1:5) = atom_name(1:1) // '    '
          end if
          call hash_get( atom_name, grain_hash_num )
          if (grain_hash_num .eq. 0) then
            print *, "Couldn't find parameters for atom/grain : ",atom_name
            STOP 6
          end if
          !if ( grain_hash_num == 0 ) call hash_get('*', grain_hash_num) ! Last chance to get a non-null value
          CutoffArrayInternal_pow2(atom_i) = ( 0.5   * dx                    + Grains_cutoff(grain_hash_num) )**2
          CutoffArrayExternal_pow2(atom_i) = ( 0.99  * (n_shells + 0.5) * dx + Grains_cutoff(grain_hash_num) )**2
      end do match_cutoff

    end subroutine fill_cutoff_array



end module SAXS_scoring
